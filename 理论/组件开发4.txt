1.Promise 是（）编程的一种解决方案  异步

2.Promise 代表成功的方法是  resolve

3.promise中接受一个数组将多个promise包装成一个新的promise实例的方法是promise.all()

4."async function fn() {
 
      await Promise.reject('出错了');

   return await Promise.resolve('hello world');
    }：
fn().then(v => console.log(v))
.catch(e => console.log(e+""外部""))执行上述代码的结果是"出错了外部

5."async function fn() {
 await Promise.resolve(""bawei"")
return await Promise.resolve(""shixun"")
   }
  fn().then(v => console.log(v))执行上述代码的结果是："shixun

6."async function f() {
 let a=await ""wangzhan""
 let b=await ""shixun""
   return {a,b};
   }
  f().then(v => console.log(v))执行上述代码的结果是"
正确答案：D
  
A.wangsan

B.shixun

C.{b: "shixun"}

D.{a: "wangzhan", b: "shixun"}

7."async function f() {
   
     await Promise.reject('出错了');
   
   return await Promise.resolve('hello world');
    }：
f().then(v => console.log(v))
.catch(e => console.log(e))"

正确答案：B

A.hello world

B."出错了"

C.报错

D.null

8.es6中箭头函数的作用域是（）形成
正确答案：C

A.运行时

B.调用时

C.定义时

D.都不对

9.Array.from()的第二个参数是（）
正确答案：B

A.截取位置

B.具有返回值的处理函数

C.合并位置

D.都不对

10.关于async说法错误的是
正确答案：B

A.async函数自带执行器

B. async无状态机制

C.async的返回值是promise对象

D.async可以是当作多个异步操作

11.关于all和race方法说法正确的是
正确答案：A

A.all方法必须保证所有的promise都执行resolve后才能执行成功函数

B.race方法必须保证所有的promise都执行resolve后才能执行成功函数

C.all方法如果只有一个状态为rejected的promise，其他为resolved状态，则也会执行成功函数

D.race方法内的promise不是同时执行；

12.如果一个await语句操作失败，不想中断后续await语句执行，可以在async内部使用
正确答案：C

A.then()

B.err(){}

C.try{}catch{}

D.都不对

13.属于async函数不正确使用形式的有（）
正确答案：D

A.async function foo() {}

B.const foo = async function () {};

C.let obj = { async foo() {} };

D.let obj = { foo:async foo() {} };

14.关于下面对象解构中会报错的是(    )
正确答案：AD

A."var foo;

  { foo: foo } = { foo: 1 };"

B.({} = [true, false])

C.({} = 'abc')

D.{} = []

15.下面关于对象解构会使用默认值的有(      )
正确答案：CD

A.let { baz: aa, zoo: { hh } } = { baz: 'baz', zoo: null };

B.var { x = 3 } = { x: null };

C.var { x = 3 } = { x: undefined };

D.var { x = 3 } = {};

16.async函数内部return语句返回的值，会成为then方法回调函数的参数
正确答案：A

A 对	B 错

17.正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即reject的 Promise 对象
正确答案：B

A 对	B 错

18.await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到
正确答案：A

A 对	B 错

19.await命令可以用在普通函数
正确答案：B

A 对	B 错

20.Promise.all方法必须保证所有的promise都为resolved状态时，才会执行成功回调
正确答案：A

A 对	B 错

21.（）方法必须保证所有的promise都为resolved状态时，才会执行成功回调  Promise.all

22.如果一个await语句操作失败，不想中断后续await语句执行，可以在async内部使用  try{}catch{}

23.async函数内部return语句返回的值，会成为( )方法回调函数的参数 then

24. async函数内部抛出错误，会导致返回的 Promise 对象变为( )状态。reject

25.async函数内部抛出错误,抛出的错误对象会被( )方法回调函数接收到 catch


26.promise中接受一个数组将多个promise包装成一个新的promise实例的方法是（）        
	
正确答案：C

A.then

B.catch

C.all

D.都不对

27.在es6中，Promise 代表成功的方法是 
正确答案：D

A.reject

B.then

C.都不对

D.resolve

28."下列代码执行：
 async function f() {
   try {
      await Promise.reject('出错了');
   } catch(e) {
     console.log(e+""内部"")
   }
   return await Promise.resolve('hello world');
    }：
f().then(v => console.log(v))
.catch(e => console.log(e+""外部""))         
	知识点：es6的async函数，源于：练习手册第4单元"
正确答案：A
	
A.出错了内部

B.出错了外部

C.hello world内部

D.hello world外部

29."
async function f() {
 await Promise.resolve(""bawei"")
 await Promise.reject(""shixun"")
   return 'hello world';
   }

  f().then(v => console.log(v))
  
  对上面代码执行得到的结果为（）知识点：es6的async函数；源于：练习手册第4单元"
正确答案：A

A.hello world

B.bawei

C.shixun

D.报错

30.es6中，关于下面async函数书写正确的有 
正确答案：C

A."async function *(ms) {
   await new Promise((resolve) => {
     setTimeout(resolve, ms);
      });
   }"

B."async function *timeout(ms) {
   await new Promise((resolve) => {
     setTimeout(resolve, ms);
      });
   }"

C."async function timeout(ms) {
   await new Promise((resolve) => {
     setTimeout(resolve, ms);
      });
   }"

D."async *function timeout(ms) {
   await new Promise((resolve) => {
     setTimeout(resolve, ms);
      });
   }"

31.在es6中，关于async说法错误的是
正确答案：B

A.async函数自带执行器

B.async无状态机制

C.async的返回值是promise对象

D.async可以是当作多个异步操作

32.在es6中，关于all和race方法说法正确的是   知识点：es6的asycn函数；源于：自出
正确答案：A

A. all方法必须保证所有的promise都执行resolve后才能执行成功函数

B.race方法必须保证所有的promise都执行resolve后才能执行成功函数

C.all方法如果只有一个状态为rejected的promise，其他为resolved状态，则也会执行成功函数

D.race方法内的promise不是同时执行；

33.在es6中，关于promise说法错误是       知识点：es6的asycn函数；源于：自出
正确答案：D

A.Promise 是异步编程的一种解决方案

B.Promise 是一个对象，从它可以获取异步操作的消息 

C.Promise 对象的状态不受外界影响

D.Promise 的状态可以多次改变

34.关于es6中，下面对象解构中会报错的是(    )：     知识点：es6的asycn函数；源于：自出
正确答案：AD

A."var foo;{ foo: foo } = { foo: 1 };"

B.({} = [true, false])

C. ({} = 'abc')

D.{} = []

35.关于es6中，下面关于对象解构会使用默认值的有(      )：   知识点：es6的asycn函数；源于：自出
正确答案：CD

A.let { baz: aa, zoo: { hh } } = { baz: 'baz', zoo: null };

B.var { x = 3 } = { x: null };

C.var { x = 3 } = { x: undefined };

D.var { x = 3 } = {};

36.async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。   
	知识点：es6的asycn函数；源于：自出
正确答案：A

A 对	B 错

37.只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行       
	知识点：es6的asycn函数；源于：自出
正确答案：A

A 对	B 错

38.await命令可以用在普通函数     知识点：es6的asycn函数；源于：自出
正确答案：B

A 对	B 错

39.在es6中，使用promise失败的方法是resolve
正确答案：B

A 对	B 错

40.关于es6中，属于async函数正确使用形式的有let obj = { foo:async foo() {} };
正确答案：B

A 对	B 错

41.var { x = 3 } = { x: undefined };congsole.log(x)的结果为3

42.在es6中提供了一种从对象取值并赋值给一个新变量的机制，这种机制叫做对象解构

